--- vcl/source/gdi/outdev3.cxx	2005-09-09 20:06:26.000000000 +0800
+++ vcl/source/gdi/outdev3.cxx	2005-09-19 14:05:58.000000000 +0800
@@ -1857,7 +1857,12 @@ void ImplDevFontList::Add( ImplFontData*
 {
     int nAliasQuality = pNewData->mnQuality - 100;
     String aMapNames = pNewData->maMapNames;
-    pNewData->maMapNames = String();
+    // Modify by Firefly(firefly@firefly.idv.tw)
+    // Don't clean maMapNames.
+    // Because some Asian Document have use alias font name.
+    //pNewData->maMapNames = String();
+    if (pNewData->maMapNames.Len())
+	mbMapNames = true;
 
     bool bKeepNewData = false;
     for( xub_StrLen nMapNameIndex = 0; nMapNameIndex != STRING_NOTFOUND; )
@@ -1927,7 +1932,9 @@ ImplDevFontListData* ImplDevFontList::Im
     // use the font's alias names to find the font
     // TODO: get rid of linear search
     DevFontList::const_iterator it = maDevFontList.begin();
-    while( it != maDevFontList.end() )
+    // Modify by Firefly(firefly@firefly.idv.tw)
+    // BUG! endless loop.
+    for( ; it != maDevFontList.end() ; ++it)
     {
         ImplDevFontListData* pData = (*it).second;
         if( !pData->maMapNames.Len() )
@@ -1957,6 +1964,10 @@ ImplDevFontListData* ImplDevFontList::Fi
     String aName = rFontName;
     ImplGetEnglishSearchFontName( aName );
     ImplDevFontListData* pFound = ImplFindBySearchName( aName );
+    // Add by Firefly(firefly@firefly.idv.tw)
+    // because CJK fonts maybe have alias name
+    if (!pFound)
+	pFound = ImplFindByAliasName(rFontName, String());
     return pFound;
 }
 
@@ -2784,12 +2795,50 @@ ImplDevFontListData* ImplDevFontList::Im
         if( pFoundData )
             return pFoundData;
 
+	// Add by Firefly(firefly@firefly.idv.tw)
+	// Search the alias names of the installed fonts too.
+        if( mbMapNames )
+        {
+            pFoundData = ImplFindByAliasName( rFSD.maTargetName, String() );
+            if( pFoundData )
+                return pFoundData;
+        }
+
         // break after last font token
         if( nTokenPos == STRING_NOTFOUND)
             break;
         bMultiToken = true;
     }
 
+    // Add by Firefly(firefly@firefly.idv.tw)
+    // use User define fontlist
+    const char *pEnv = ::getenv("OOO_PREFER_FONT_LIST");
+    if (pEnv)
+    {
+        String aPreferName(pEnv, RTL_TEXTENCODING_UTF8);
+        nTokenPos = 0;	
+        for(;;)
+        {
+	    rFSD.maTargetName = GetNextFontToken(aPreferName, nTokenPos);
+	    aSearchName = rFSD.maTargetName;
+            ImplGetEnglishSearchFontName(aSearchName);
+	    ImplDevFontListData* pFoundData = ImplFindBySearchName(aSearchName);
+	    if( pFoundData )
+		return pFoundData;
+
+	    if( mbMapNames )
+	    {
+		pFoundData = ImplFindByAliasName(rFSD.maTargetName, String());
+		if(pFoundData)
+		    return pFoundData;
+	    }
+
+	    // break after last font token
+	    if(nTokenPos == STRING_NOTFOUND)
+		break;
+	}
+    }
+
     // if the first font was not available find the next available font in
     // the semicolon separated list of font names. A font is also considered
     // available when there is a matching entry in the Tools->Options->Fonts
@@ -3030,7 +3079,32 @@ ImplFontEntry* ImplFontCache::GetFallbac
         int nMaxLevel = 0;
         int nBestQuality = 0;
         ImplDevFontListData** pFallbackList = NULL;
-        for( const char** ppNames = &aGlyphFallbackList[0];; ++ppNames )
+ 	// Add by Firefly(firefly@firefly.idv.tw)
+ 	const char *pEnv = ::getenv("OOO_PREFER_FONT_LIST");
+ 	bool bPrefer = false;
+ 	if (pEnv)
+ 	{
+ 	    String aPreferName(pEnv, RTL_TEXTENCODING_UTF8);
+             String aTempName;
+             xub_StrLen nIndex = 0;
+             do
+             {
+ 		aTempName = GetNextFontToken(aPreferName, nIndex);
+ 		ImplDevFontListData* pFallbackFont = pFontList->FindFontFamily(aTempName);
+ 		if (pFallbackFont && pFallbackFont->IsScalable())
+ 		{
+ 		    bPrefer = true;
+ 		    if(!pFallbackList)
+ 			pFallbackList = new ImplDevFontListData*[ MAX_FALLBACK ];
+ 		    pFallbackList[nMaxLevel++] = pFallbackFont;
+ 		    if (nMaxLevel >= MAX_FALLBACK)
+ 			break;
+ 		}
+ 	    }
+ 	    while ( nIndex != STRING_NOTFOUND );
+ 	}
+ 	//---------------------------------------------------------
+        for( const char** ppNames = &aGlyphFallbackList[0]; *ppNames && !bPrefer; ++ppNames )
         {
             // advance to next sub-list when end-of-sublist marker
             if( !**ppNames )    // #i46456# check for empty string, i.e., deref string itself not only ptr to it
