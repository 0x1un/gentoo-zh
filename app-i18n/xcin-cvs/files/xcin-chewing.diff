diff -uNrp xcin-cvs/configure xcin-chewing/configure
--- xcin-cvs/configure	2004-02-01 01:10:38.000000000 +0800
+++ xcin-chewing/configure	2004-06-08 01:42:05.000000000 +0800
@@ -25387,7 +25387,7 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
-                                                                                                                                                                                                                            ac_config_files="$ac_config_files Makefile:script/Makefile.in Rules:script/Rules.in src/Makefile src/lib/Makefile src/lib/xcintool/Makefile src/lib/charset/Makefile src/lib/siod/Makefile src/lib/IMdkit/Makefile src/Cinput/Makefile src/Cinput/im_comm/Makefile src/Cinput/zh_hex/Makefile src/Cinput/gen_inp/Makefile src/Cinput/bimsphone/Makefile src/util/Makefile src/util/cin2tab/Makefile src/util/testprog/Makefile cin/Makefile cin/big5/Makefile cin/gb/Makefile etc/Makefile po/Makefile doc/man/Makefile"
+                                                                                                                                                                                                                            ac_config_files="$ac_config_files Makefile:script/Makefile.in Rules:script/Rules.in src/Makefile src/lib/Makefile src/lib/xcintool/Makefile src/lib/charset/Makefile src/lib/siod/Makefile src/lib/IMdkit/Makefile src/Cinput/Makefile src/Cinput/im_comm/Makefile src/Cinput/zh_hex/Makefile src/Cinput/gen_inp/Makefile src/Cinput/chewing/Makefile src/Cinput/bimsphone/Makefile src/util/Makefile src/util/cin2tab/Makefile src/util/testprog/Makefile cin/Makefile cin/big5/Makefile cin/gb/Makefile etc/Makefile po/Makefile doc/man/Makefile"
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -25924,6 +25924,7 @@ do
   "src/Cinput/im_comm/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Cinput/im_comm/Makefile" ;;
   "src/Cinput/zh_hex/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Cinput/zh_hex/Makefile" ;;
   "src/Cinput/gen_inp/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Cinput/gen_inp/Makefile" ;;
+  "src/Cinput/chewing/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Cinput/chewing/Makefile" ;;
   "src/Cinput/bimsphone/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Cinput/bimsphone/Makefile" ;;
   "src/util/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/util/Makefile" ;;
   "src/util/cin2tab/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/util/cin2tab/Makefile" ;;
diff -uNrp xcin-cvs/src/Cinput/chewing/.depend xcin-chewing/src/Cinput/chewing/.depend
--- xcin-cvs/src/Cinput/chewing/.depend	1970-01-01 08:00:00.000000000 +0800
+++ xcin-chewing/src/Cinput/chewing/.depend	2004-06-08 13:08:21.000000000 +0800
@@ -0,0 +1,9 @@
+#
+# PLEASE DON'T EDIT.
+#
+# This is automatically generated from "make depend".
+# You need GCC and perl to generate me.
+#
+
+xcin_chewing.lo: xcin_chewing.c  ../../../config.h ../../../src/include/xcintool.h ../../../src/include/module.h
+	@$(LIBTOOL) --mode=compile $(CC) $(CFLAGS) $(DEFS) $(INC) -c -o $@ xcin_chewing.c
diff -uNrp xcin-cvs/src/Cinput/chewing/Makefile.in xcin-chewing/src/Cinput/chewing/Makefile.in
--- xcin-cvs/src/Cinput/chewing/Makefile.in	1970-01-01 08:00:00.000000000 +0800
+++ xcin-chewing/src/Cinput/chewing/Makefile.in	2004-06-08 01:42:05.000000000 +0800
@@ -0,0 +1,29 @@
+srcdir		= @srcdir@
+top_srcdir	= @top_srcdir@
+include $(top_srcdir)/Rules
+
+INC		= $(xcininc) $(intl_inc) $(x_includes) -I$(top_srcdir)
+LIB		= $(xcinlib) -lchewing
+TARGET		= chewing.la
+
+SRC = xcin_chewing.c
+OBJ = $(SRC:.c=.lo)
+
+.PHONY: depend clean distclean
+
+all: depend $(TARGET)
+
+$(TARGET): $(OBJ)
+	$(LIBTOOL) --mode=link $(CC) -module -avoid-version -o $(TARGET) \
+		$(OBJ) $(LIB) -rpath $(moddir)
+include .depend
+
+depend:
+	$(Dep_Rule) | $(PERL) $(makedep) $(rules) LC_Rule lo > .depend
+
+clean:
+	rm -f $(OBJ) *.o $(TARGET) core *.a
+distclean: clean
+	rm -rf Makefile .libs
+install: $(TARGET)
+	$(LIBTOOL) --mode=install $(INSTALL_DATA) $(TARGET) $(xcin_modp)
diff -uNrp xcin-cvs/src/Cinput/chewing/xcin_chewing.c xcin-chewing/src/Cinput/chewing/xcin_chewing.c
--- xcin-cvs/src/Cinput/chewing/xcin_chewing.c	1970-01-01 08:00:00.000000000 +0800
+++ xcin-chewing/src/Cinput/chewing/xcin_chewing.c	2004-06-08 13:08:05.000000000 +0800
@@ -0,0 +1,493 @@
+/*
+ this file is the interface between chewing and xcin
+*/
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <chewing/chewingio.h>
+#include <chewing/hash.h>
+/* XXX: #include <chewing/console_chewing.h> */
+#include <chewing/dict.h>
+#include <chewing/zuin.h>
+#include <chewing/char.h>
+#include <string.h>
+
+#include <X11/Xlib.h>
+#include <X11/keysym.h>
+#include "xcintool.h"
+#include "module.h"
+
+#define DBG(msg) \
+  fprintf(stderr, "\033[44;37m" msg "\033[m\n")
+
+// the following keystate masks are defined by xcin
+#define CAPS_MASK (2)
+#define CTRL_MASK (4)
+
+#include <iconv.h>
+#include <langinfo.h>
+#define XCIN_BYTE_NATIVE   2
+#define XCIN_BYTE_UTF8     3
+static int bimsp_codeset;
+void preconvert(char *input, char *output, int n_char);
+wchar_t convert(wchar_t input);
+
+/* statistics symbol required by chewing */
+int lifetime ;
+
+int MakeInpinfo(inpinfo_t *inpinfo, ChewingOutput *pgo) ;
+
+int CallSetConfig(inpinfo_t *inpinfo, ChewingData *pgdata)
+{
+  ConfigData config ;
+  int i ;
+  
+  /*  config.selectAreaLen = inpinfo->xcin_wlen ;
+  if (config.selectAreaLen == 0)
+    config.selectAreaLen = 80 ; */
+  config.selectAreaLen = 40;
+  // config.maxChiSymbolLen = 22 ;
+  config.maxChiSymbolLen = 16;
+
+  for(i=0; i<9; i++)
+    config.selKey[i] = i + '1' ;
+  config.selKey[9] = '0' ;
+  SetConfig(pgdata, &config) ;
+  return 0 ;
+}
+
+static int
+ChewingInit(void *conf, char *objname, xcin_rc_t *xc)
+{
+  char *cmd[2], kb_type_str[256];
+  ChewingConf *cf = (ChewingConf *)conf ;
+
+  char *prefix = "/usr/share/chewing";
+	/* Because libtabe uses BIG-5 encoding for all its structure
+	       so we need to check if it is UTF-8 locale and do any conv */
+	char *codeset;
+	codeset=nl_langinfo(CODESET);
+	if ( ! strcasecmp(codeset,"UTF-8") )
+		bimsp_codeset=XCIN_BYTE_UTF8;
+	else
+		bimsp_codeset=XCIN_BYTE_NATIVE;
+  char *cname = (char *)calloc(3,sizeof(char)*bimsp_codeset);
+
+  cmd[0] = objname ;
+  cmd[1] = "KB_TYPE" ;
+  kb_type_str[0] = '\0' ;
+  get_resource(xc, cmd, kb_type_str, 200, 2) ;
+  cf->kb_type = KBStr2Num(kb_type_str) ;
+
+
+  preconvert("·s»Å­µ", cname, 6);
+  cf->inp_cname = strdup(cname) ; 
+  cf->inp_ename = strdup("Chewing") ;
+  
+  /* Initialize Chewing */
+  ReadTree(prefix) ;
+  InitChar(prefix) ;
+  InitDict(prefix) ;
+  ReadHash(prefix) ;
+  
+  return True ;
+}
+
+static int 
+ChewingXimInit(void *conf, inpinfo_t *inpinfo)
+{
+  static char cchBuffer[MAX_PHONE_SEQ_LEN] ;
+  ChewingConf *cf = (ChewingConf *)conf ;
+  int i;
+
+  inpinfo->iccf = (ChewingData *) calloc(1, sizeof(ChewingData)) ;
+  
+  InitChewing(inpinfo->iccf, cf) ;
+  CallSetConfig(inpinfo, (ChewingData *) inpinfo->iccf) ;
+
+  inpinfo->lcch = (wch_t *) calloc(MAX_PHONE_SEQ_LEN, sizeof(wch_t)) ;
+  inpinfo->lcch_grouping = (ubyte_t *) calloc(MAX_PHONE_SEQ_LEN, sizeof(ubyte_t) );
+  inpinfo->cch = cchBuffer ; // 2000.6.30
+
+  inpinfo->inp_cname = cf->inp_cname;
+  inpinfo->inp_ename = cf->inp_ename;
+  inpinfo->area3_len = 2 * ZUIN_SIZE + 4;
+  inpinfo->guimode = GUIMOD_LISTCHAR | GUIMOD_SELKEYSPOT;
+  inpinfo->keystroke_len = 0;
+  inpinfo->s_keystroke = (wch_t *) calloc(3 + MAX_PHRASE_LEN, sizeof(wch_t)) ;
+
+  inpinfo->mcch = (wch_t *) calloc( MAX_CHOICE_BUF, sizeof(wch_t) );
+  inpinfo->mcch_grouping = (ubyte_t *) calloc( MAX_SELKEY, sizeof(ubyte_t) );
+  inpinfo->n_mcch = 0;
+
+  inpinfo->n_lcch = 0;
+  inpinfo->edit_pos = 0;
+  inpinfo->cch_publish.wch = (wchar_t)0;
+
+  //  check_winsize(inpinfo, iccf);
+  //  [yet] check winsize is under construction.
+
+  inpinfo->n_selkey = 10;
+  inpinfo->s_selkey = (wch_t *) calloc( MAX_SELKEY, sizeof(wch_t) );
+
+  for (i=0; i<9; i++) {
+    inpinfo->s_selkey[i].wch  = (wchar_t)0;
+    inpinfo->s_selkey[i].s[0] = i + '1';
+  }
+  inpinfo->s_selkey[9].wch  = (wchar_t)0;
+  inpinfo->s_selkey[9].s[0] = '0';
+
+  return True ;
+}
+
+void CommitString(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+  int i ;
+  char *str;
+  char *output;
+  memset(inpinfo->cch, 0, sizeof(char)*MAX_PHONE_SEQ_LEN) ;
+  str = (char *)calloc(MAX_PHONE_SEQ_LEN,sizeof(char));
+  output = (char *)calloc(MAX_PHONE_SEQ_LEN/2*bimsp_codeset,sizeof(char));
+  for(i=0; i<pgo->nCommitStr; i++)
+    strcat(str, (const char *)pgo->commitStr[i].s) ;
+  /*str[i] = '\0';*/
+  preconvert(str, output, strlen(str));
+  strcat(inpinfo->cch, output);
+  free(str);
+  free(output);
+}
+
+static unsigned int 
+ChewingXimEnd(void *conf, inpinfo_t *inpinfo)
+{
+  ChewingOutput gOut ;
+  int rtn ;
+
+  /* if preedit exists, commit the string */
+  OnKeyEnter(inpinfo->iccf, &gOut) ;
+  
+  rtn = MakeInpinfo(inpinfo, &gOut) ;
+  free(inpinfo->iccf);
+  free(inpinfo->s_keystroke);
+  free(inpinfo->lcch);
+  free(inpinfo->mcch);
+  free(inpinfo->mcch_grouping);
+
+  inpinfo->iccf = NULL;
+  inpinfo->s_keystroke = NULL;
+  inpinfo->lcch = NULL;
+
+    // under construction
+  return rtn ;
+}      
+
+void ShowChoose(inpinfo_t *inpinfo, ChoiceInfo *pci, ChewingOutput *pgo)
+{
+  int i,no,k,len, kk;
+  char *output;
+  
+  // for new xcin, there is no need to modify the lcch buffer
+  // instead, we put phrase to choose in mcch
+  no = pci->pageNo * pci->nChoicePerPage;
+  len = 0;
+
+  for(i=0;i<pci->nChoicePerPage; no++,i++) {
+
+    // in the last page, no will exceed nTotalChoice
+    if( no >= pci->nTotalChoice ) 
+      break;
+	  output = (char *)calloc(strlen(pci->totalChoiceStr[no])*bimsp_codeset+1, sizeof(char));
+	  preconvert(pci->totalChoiceStr[no], output, strlen(pci->totalChoiceStr[no]));
+    // for each char in the phrase, copy to mcch
+    for(k=0, kk = 0; output[k]!='\0'; k+=bimsp_codeset, kk++) {
+      memcpy(inpinfo->mcch[len++].s, &(output[k]), bimsp_codeset) ;
+    }
+    free(output);
+    // set grouping to the length of the phrase
+    inpinfo->mcch_grouping[i+1] = kk;
+  }
+  // i stores how many choices are available
+  inpinfo->mcch_grouping[0] = i;
+
+  // set pgstate according to pci->pageNo & pci->nPage
+  if( pci->nPage == 1) {
+    inpinfo->mcch_pgstate = MCCH_ONEPG;
+  }
+  else {
+    if( pci->pageNo == 0 )
+      inpinfo->mcch_pgstate = MCCH_BEGIN;
+    else if( pci->pageNo == pci->nPage - 1)
+      inpinfo->mcch_pgstate = MCCH_END;
+    else
+      inpinfo->mcch_pgstate = MCCH_MIDDLE;
+  }
+
+  inpinfo->n_mcch = len ;
+}
+
+void ShowText(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+	int i;
+  memset(inpinfo->lcch, 0, sizeof(wch_t)*MAX_PHONE_SEQ_LEN) ;
+  for(i = 0; i < pgo->chiSymbolBufLen; i++)
+	  pgo->chiSymbolBuf[i].wch = convert(pgo->chiSymbolBuf[i].wch);
+  memcpy(inpinfo->lcch, pgo->chiSymbolBuf, sizeof(wch_t) * pgo->chiSymbolBufLen) ;
+  inpinfo->n_lcch = pgo->chiSymbolBufLen ;
+}
+
+void ShowInterval(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+  int i, k, begin, len, count, nGroup ;
+  int label[MAX_PHONE_SEQ_LEN] ;
+
+  if( pgo->chiSymbolBufLen == 0) {
+    inpinfo->lcch_grouping[0] = 0 ;
+    return ;
+  }
+
+  // set label
+  for(count=0; count<pgo->chiSymbolBufLen; count++)
+    label[count] = count ;
+
+  for(i=0; i<pgo->nDispInterval; i++) {
+    len = pgo->dispInterval[i].to - pgo->dispInterval[i].from ;
+
+    if( len > 1) {
+      for(k=pgo->dispInterval[i].from; k<pgo->dispInterval[i].to; k++)
+	label[k] = count ;
+      count++ ;
+    }
+  }
+
+  // begin to set lcch_grouping by the label
+  nGroup = 0 ;
+  begin = 0 ;
+  for(i=1; i<pgo->chiSymbolBufLen; i++) {
+    if( label[i] != label[begin] ) {
+      inpinfo->lcch_grouping[++nGroup] = ( i - begin ) ;
+      begin = i ;
+    }
+  }
+  inpinfo->lcch_grouping[++nGroup] = ( i - begin ) ;
+  inpinfo->lcch_grouping[0] = nGroup ;
+}
+
+void ShowStateAndZuin(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+  int i, a , len = 0;
+  memset( inpinfo->s_keystroke, 0, sizeof(wch_t)*(3 + MAX_PHRASE_LEN)) ;
+  if(pgo->bShowMsg) {
+	  for(i = 0; i < pgo->showMsgLen; i++)
+		  pgo->showMsg[i].wch = convert(pgo->showMsg[i].wch);
+    memcpy( inpinfo->s_keystroke, pgo->showMsg, sizeof(wch_t)*pgo->showMsgLen) ;
+    inpinfo->keystroke_len = pgo->showMsgLen ;
+  }
+  else {
+ /*   if(pgo->bChiSym)
+      strcpy( (char *)inpinfo->s_keystroke[0].s, "¤¤") ;
+    else
+      strcpy( (char *)inpinfo->s_keystroke[0].s, "­^") ;
+    
+    inpinfo->s_keystroke[1].s[0] = ' ' ;
+    for(i=0,a=2; i<ZUIN_SIZE; i++) */
+    for(i=0,a=0; i<ZUIN_SIZE; i++)
+      if(pgo->zuinBuf[i].s[0] != '\0') {
+	inpinfo->s_keystroke[a++].wch = convert(pgo->zuinBuf[i].wch) ;
+        ++ len;
+      }
+    inpinfo->keystroke_len = len;
+  }
+}
+
+void SetCursor(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+  inpinfo->edit_pos = pgo->chiSymbolCursor;
+}
+
+int MakeInpinfo(inpinfo_t *inpinfo, ChewingOutput *pgo)
+{
+  int rtnValue = 0 ;
+
+  if(pgo->keystrokeRtn & KEYSTROKE_ABSORB)
+    rtnValue |= IMKEY_ABSORB ;
+  if(pgo->keystrokeRtn & KEYSTROKE_IGNORE)
+    rtnValue |= IMKEY_IGNORE ;
+  if(pgo->keystrokeRtn & KEYSTROKE_BELL)
+    rtnValue |= IMKEY_BELL ;
+  if(pgo->keystrokeRtn & KEYSTROKE_COMMIT) {
+    rtnValue |= IMKEY_COMMIT ;
+    CommitString(inpinfo, pgo) ;
+  }
+
+  if(pgo->pci->nPage != 0) { // in selection mode
+    ShowChoose(inpinfo,pgo->pci,pgo) ;
+    inpinfo->guimode &= ~GUIMOD_LISTCHAR; 
+  }
+  else { // not in selection mode
+    ShowText(inpinfo, pgo) ;
+    ShowInterval(inpinfo, pgo) ; // kpchen 2000.2.9
+    inpinfo->guimode |= GUIMOD_LISTCHAR;
+  }
+  ShowStateAndZuin(inpinfo, pgo) ;
+  SetCursor(inpinfo, pgo) ;
+  return rtnValue ;
+}
+
+static unsigned int
+ChewingKeystroke(void *conf, inpinfo_t *inpinfo, keyinfo_t *keyinfo)
+{
+  KeySym keysym = keyinfo->keysym;
+  ChewingOutput gOut ;
+  int rtn ;
+  static KeySym last_key = 0;
+
+  // set Chinese / English mode by keystate
+  if( keyinfo->keystate & CAPS_MASK ) { // uppercase
+    SetChiEngMode( inpinfo->iccf, SYMBOL_MODE);
+  }
+  else {  // lower case 
+    SetChiEngMode( inpinfo->iccf, CHINESE_MODE);
+  }
+
+
+  // check no ctrl key was pressed
+  if(keyinfo->keystate >= 0 && !(keyinfo->keystate & CTRL_MASK) ) {
+    switch(keysym) {
+    case XK_Escape:
+      OnKeyEsc(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Return:
+      OnKeyEnter(inpinfo->iccf, &gOut) ;
+      inpinfo->n_mcch = 0;
+      break ;
+    case XK_Delete:
+      OnKeyDel(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_BackSpace:
+      OnKeyBackspace(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Up:
+      OnKeyUp(inpinfo->iccf, &gOut);
+      break ;
+    case XK_Down:
+      OnKeyDown(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Left:
+      OnKeyLeft(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Right:
+      OnKeyRight(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Home:
+      OnKeyHome(inpinfo->iccf, &gOut);
+      break;
+    case XK_End:
+      OnKeyEnd(inpinfo->iccf, &gOut);
+      break;
+
+    case XK_Tab:
+      if( last_key == XK_Tab) // double click TAB
+	OnKeyDblTab(inpinfo->iccf, &gOut);
+      else
+	OnKeyTab(inpinfo->iccf, &gOut) ;
+      break ;
+    case XK_Caps_Lock:
+      OnKeyCapslock(inpinfo->iccf, &gOut) ;
+      break ;
+    default:
+      OnKeyDefault(inpinfo->iccf,keysym,&gOut ) ;
+      break ;
+    }
+  }
+  
+  else if(keyinfo->keystate & CTRL_MASK) {  // Ctrl-key Mask
+  // We need to fill the 'gOut' variable for output.
+    if(keysym <= '9' && keysym >= '0') 
+      OnKeyCtrlNum(inpinfo->iccf,keysym,&gOut) ;    
+    else
+      OnKeyCtrlDefault(inpinfo->iccf,&gOut) ;
+  }
+
+
+  last_key = keysym;
+  rtn = MakeInpinfo(inpinfo, &gOut) ;
+  return rtn ;
+}
+
+static int 
+ChewingShowKeystroke(void *conf, simdinfo_t *simdinfo)
+{
+  simdinfo->s_keystroke = NULL;
+  return False;
+}                              
+
+/* --------------- Additional for UTF-8 support ----------------- */
+void
+preconvert(char *input, char *output, int n_char)
+{
+    if(bimsp_codeset == XCIN_BYTE_UTF8) {
+        const char *inptr = input;
+        size_t inbytesleft = n_char;
+        size_t outbytesleft = n_char/2*3 +1;
+        
+        char *outptr = output;
+    
+        iconv_t cd;
+    
+        cd = iconv_open("UTF-8", "BIG-5");
+        iconv (cd, (char **)&inptr, &inbytesleft, &outptr, &outbytesleft);
+        
+        iconv_close(cd);
+    }
+    else 
+	strncpy(output, input, n_char);
+}
+
+wchar_t
+convert(wchar_t input)
+{
+	wch_t output;
+	wch_t temp;
+
+	temp.wch = input;
+	if (bimsp_codeset == XCIN_BYTE_UTF8)
+	{
+		const char *inptr = temp.s;
+		size_t inbytesleft = 2;
+		size_t outbytesleft = 3;
+		char *outptr = output.s;
+		iconv_t cd;
+		cd = iconv_open("UTF-8", "BIG-5");
+		iconv (cd, (char **)&inptr, &inbytesleft, &outptr, &outbytesleft);
+		iconv_close(cd);
+		output.s[3] = '\0';
+		return output.wch;
+	}
+
+	return input;
+}
+
+static char zh_chewing_comments[] = 
+"This is a very smart phonetic input method module.\n"
+"By Lu-chuan Kung <lckung@iis.sinica.edu.tw> and\n"
+"And Kang-pen Chen <kpchen@iis.sinica.edu.tw>.\n";
+
+static char *zh_chewing_valid_objname[] = { "chewing", NULL };
+     
+module_t module_ptr = {
+  { MTYPE_IM,
+    "zh_chewing",				/* name */
+    MODULE_VERSION,				/* version */
+    zh_chewing_comments },			/* comments */
+  zh_chewing_valid_objname,			/* valid_objname */
+  sizeof(ChewingConf),				/* conf_size */
+  ChewingInit,					/* init */
+  ChewingXimInit,				/* xim_init */
+  ChewingXimEnd,				/* xim_end */
+  ChewingKeystroke,				/* keystroke */
+  ChewingShowKeystroke,				/* show_keystroke */
+  NULL
+};
+
diff -uNrp xcin-cvs/src/Cinput/Makefile.in xcin-chewing/src/Cinput/Makefile.in
--- xcin-cvs/src/Cinput/Makefile.in	2004-01-25 00:52:40.000000000 +0800
+++ xcin-chewing/src/Cinput/Makefile.in	2004-06-08 01:42:05.000000000 +0800
@@ -1,4 +1,4 @@
-SUBSYS = zh_hex gen_inp @extra_modules@
+SUBSYS = zh_hex gen_inp chewing @extra_modules@
 OTHERS = im_comm
 
 .PHONY: depend subdirs clean distclean install
diff -uNrp xcin-cvs/src/include/module.h xcin-chewing/src/include/module.h
--- xcin-cvs/src/include/module.h	2004-02-09 01:57:02.000000000 +0800
+++ xcin-chewing/src/include/module.h	2004-06-08 01:42:05.000000000 +0800
@@ -278,7 +278,7 @@ extern KeySym keysym_ascii(int ch);
 
 /* Quick key phrase: %trigger, %shift, %ctrl, %alt  */
 extern void qphrase_init(xcin_rc_t *xrc, char *phrase_fn);
-extern char *qphrase_str(int ch, int class);
+extern char *qphrase_str(int ch, int _class);
 extern char *get_qphrase_list(void);
 
 /* GUI Request registration */
diff -uNrp xcin-cvs/src/include/xcintool.h xcin-chewing/src/include/xcintool.h
--- xcin-cvs/src/include/xcintool.h	2004-02-09 01:57:02.000000000 +0800
+++ xcin-chewing/src/include/xcintool.h	2004-06-08 01:42:05.000000000 +0800
@@ -197,12 +197,14 @@ enum rctype {
 };
 
 /* XCIN global resources. */
+#ifndef  __USE_GNU
 typedef struct {
     char *lc_ctype;
     char *lc_messages;
     char *encoding;
     int encid, locid;
 } locale_t;
+#endif
 
 typedef struct {
     int argc;			/* Command line arguement list */
